from __future__ import annotations
import inspect
import pathlib
from textwrap import indent as tw_indent
import typing

import cdp


def indent(text, count):
    ''' Indent text with the specified number of spaces. '''
    return tw_indent(text, ' '  * count)


def main():
    ''' Main entry point. '''
    root = pathlib.Path(__file__).resolve().parent.parent / 'trio_cdp' / 'generated'
    clean(root)
    modules = list()
    for name, module in inspect.getmembers(cdp):
        if name.startswith('_') or name in ('cdp', 'util'):
            continue
        modules.append(name)
        generate_module(root, name, module)
    init = root / '__init__.py'
    with init.open('w') as file:
        file.write('# DO NOT EDIT THIS FILE!\n#\n')
        file.write('# This code is generated off of PyCDP modules. If you need to make\n')
        file.write('# changes, edit the generator and regenerate all of the modules.\n\n')
        for module in modules:
            file.write(f'from . import {module}\n')


def clean(root):
    ''' Remove files from directory. '''
    for path in root.iterdir():
        if path.is_file():
            path.unlink()


def generate_module(root, module_name, module):
    ''' Generate code for a module. '''
    print('* Generating module:', module_name)
    module_path = root / f'{module_name}.py'
    commands = list()
    classes = list()
    for name, obj in inspect.getmembers(module):
        if name.startswith('_') or name in ('dataclass', 'event_class'):
            continue
        if inspect.isfunction(obj):
            commands.append(generate_command(module_name, name, obj))
        elif inspect.isclass(obj):
            classes.append(name)

    with module_path.open('w') as file:
        file.write('# DO NOT EDIT THIS FILE!\n#\n')
        file.write('# This code is generated off of PyCDP modules. If you need to make\n')
        file.write('# changes, edit the generator and regenerate all of the modules.\n\n')
        file.write('from __future__ import annotations\n')
        file.write('import typing\n\n')
        file.write('from ..context import get_connection_context, get_session_context\n\n')
        file.write(f'import cdp.{module_name}\n')
        if classes:
            file.write(f'from cdp.{module_name} import (\n')
            file.write(indent(',\n'.join(classes), 4))
            file.write('\n)\n\n\n')
        else:
            file.write('\n')
        file.write('\n\n'.join(commands))


def generate_command(module, name, fn):
    ''' Generate code for one command, i.e. one PyCDP wrapper function. '''
    print(f'  - {name}()')
    sig = inspect.signature(fn)

    # Generate the argument list.
    args = list()
    call_args = list()
    for param in sig.parameters.values():
        ann = format_annotation(param.annotation)
        if param.default != inspect.Parameter.empty:
            default_str = f' = {param.default}'
        else:
            default_str = ''
        args.append(f'{param.name}: {ann}{default_str}')
        call_args.append(param.name)

    if len(args) == 0:
        args = ', '.join(args)
    else:
        args = indent('\n' + ',\n'.join(args), 8) + '\n    '
    call_args = ', '.join(call_args)

    # Copy docstring.
    if fn.__doc__:
        doc = "    '''" + fn.__doc__ + "'''\n"
    else:
        doc = ''

    # The original function returns a generator. We want to grab the return type of the
    # generator and set that as the return type of this wrapper function.
    return_type = format_annotation(sig.return_annotation.__args__[2])

    # Format the function and return it as a string.
    ctx_name, ctx_fn = which_context(module, name)
    body = f"{ctx_name} = {ctx_fn}('{module}.{name}')\n"
    body += f"return await {ctx_name}.execute(cdp.{module}.{name}({call_args}))"
    body = indent(body, 4)
    return f'async def {name}({args}) -> {return_type}:\n{doc}{body}\n'


def format_annotation(ann):
    '''
    Given a type annotation, return a stringified version.

    This is ugly since it seems there's not much official tooling for manipulating
    types. Many of the types are all of the same class ``typing._GenericAlias``, and we
    have to access private members to figure out what the specific annotation actually
    is.
    '''
    if isinstance(ann, str):
        ann_str = ann
    elif isinstance(ann, typing.ForwardRef):
        ann_str = ann.__forward_arg__
    elif ann in (bool, dict, float, int, str):
        ann_str = ann.__name__
    elif ann is type(None):
        ann_str = 'None'
    elif ann._name == 'Any':
        ann_str = 'typing.Any'
    elif ann._name == 'List':
        nested_ann = format_annotation(ann.__args__[0])
        ann_str = f'typing.List[{nested_ann}]'
    elif ann._name == 'Tuple':
        nested_anns = ', '.join(format_annotation(a) for a in ann.__args__)
        ann_str = f'typing.Tuple[{nested_anns}]'
    elif ann._name is None and len(ann.__args__) > 1:
        # For some reason union annotations don't have a name?
        # If the union has two members and one of them is NoneType, then it's really
        # a typing.Optional.
        if len(ann.__args__) == 2 and any(a is type(None) for a in ann.__args__):
            nested_ann = format_annotation(
                [a for a in ann.__args__ if a is not type(None)][0])
            ann_str = f'typing.Optional[{nested_ann}]'
        else:
            nested_anns = ', '.join(format_annotation(a) for a in ann.__args__)
            ann_str = f'typing.Union[{nested_anns}]'
    else:
        raise Exception(f'Cannot format annotation: {repr(ann)}')
    return ann_str


def which_context(module, name):
    '''
    Returns the information for which context to use when executing a particular
    function.

    Returns a tuple of the variable name for the context and the function name that
    retrieves the context.
    '''
    if module == 'target':
        context = 'connection', 'get_connection_context'
    else:
        context = 'session', 'get_session_context'
    return context

if __name__ == '__main__':
    main()

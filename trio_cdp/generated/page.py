# DO NOT EDIT THIS FILE!
#
# This code is generated off of PyCDP modules. If you need to make
# changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
import typing

from ..context import get_connection_context, get_session_context

import cdp.page
from cdp.page import (
    AppManifestError,
    ClientNavigationReason,
    CompilationCacheProduced,
    DialogType,
    DomContentEventFired,
    DownloadWillBegin,
    FileChooserOpened,
    FontFamilies,
    FontSizes,
    Frame,
    FrameAttached,
    FrameClearedScheduledNavigation,
    FrameDetached,
    FrameId,
    FrameNavigated,
    FrameRequestedNavigation,
    FrameResized,
    FrameResource,
    FrameResourceTree,
    FrameScheduledNavigation,
    FrameStartedLoading,
    FrameStoppedLoading,
    FrameTree,
    InterstitialHidden,
    InterstitialShown,
    JavascriptDialogClosed,
    JavascriptDialogOpening,
    LayoutViewport,
    LifecycleEvent,
    LoadEventFired,
    NavigatedWithinDocument,
    NavigationEntry,
    ScreencastFrame,
    ScreencastFrameMetadata,
    ScreencastVisibilityChanged,
    ScriptIdentifier,
    TransitionType,
    Viewport,
    VisualViewport,
    WindowOpen
)


async def add_compilation_cache(
        url: str,
        data: str
    ) -> None:
    '''
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    :param url:
    :param data: Base64-encoded data
    '''
    session = get_session_context('page.add_compilation_cache')
    return await session.execute(cdp.page.add_compilation_cache(url, data))


async def add_script_to_evaluate_on_load(
        script_source: str
    ) -> ScriptIdentifier:
    '''
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    :param script_source:
    :returns: Identifier of the added script.
    '''
    session = get_session_context('page.add_script_to_evaluate_on_load')
    return await session.execute(cdp.page.add_script_to_evaluate_on_load(script_source))


async def add_script_to_evaluate_on_new_document(
        source: str,
        world_name: typing.Optional[str] = None
    ) -> ScriptIdentifier:
    '''
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: If specified, creates an isolated world with the given name and evaluates given script in it.
    This world name will be used as the ExecutionContextDescription::name when the corresponding
    event is emitted.
    :returns: Identifier of the added script.
    '''
    session = get_session_context('page.add_script_to_evaluate_on_new_document')
    return await session.execute(cdp.page.add_script_to_evaluate_on_new_document(source, world_name))


async def bring_to_front() -> None:
    '''
    Brings page to front (activates tab).
    '''
    session = get_session_context('page.bring_to_front')
    return await session.execute(cdp.page.bring_to_front())


async def capture_screenshot(
        format: typing.Optional[str] = None,
        quality: typing.Optional[int] = None,
        clip: typing.Optional[Viewport] = None,
        from_surface: typing.Optional[bool] = None
    ) -> str:
    '''
    Capture page screenshot.

    :param format: Image compression format (defaults to png).
    :param quality: Compression quality from range [0..100] (jpeg only).
    :param clip: Capture the screenshot of a given region only.
    :param from_surface: Capture the screenshot from the surface, rather than the view. Defaults to true.
    :returns: Base64-encoded image data.
    '''
    session = get_session_context('page.capture_screenshot')
    return await session.execute(cdp.page.capture_screenshot(format, quality, clip, from_surface))


async def capture_snapshot(
        format: typing.Optional[str] = None
    ) -> str:
    '''
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    :param format: Format (defaults to mhtml).
    :returns: Serialized page data.
    '''
    session = get_session_context('page.capture_snapshot')
    return await session.execute(cdp.page.capture_snapshot(format))


async def clear_compilation_cache() -> None:
    '''
    Clears seeded compilation cache.
    '''
    session = get_session_context('page.clear_compilation_cache')
    return await session.execute(cdp.page.clear_compilation_cache())


async def clear_device_metrics_override() -> None:
    '''
    Clears the overriden device metrics.
    '''
    session = get_session_context('page.clear_device_metrics_override')
    return await session.execute(cdp.page.clear_device_metrics_override())


async def clear_device_orientation_override() -> None:
    '''
    Clears the overridden Device Orientation.
    '''
    session = get_session_context('page.clear_device_orientation_override')
    return await session.execute(cdp.page.clear_device_orientation_override())


async def clear_geolocation_override() -> None:
    '''
    Clears the overriden Geolocation Position and Error.
    '''
    session = get_session_context('page.clear_geolocation_override')
    return await session.execute(cdp.page.clear_geolocation_override())


async def close() -> None:
    '''
    Tries to close page, running its beforeunload hooks, if any.
    '''
    session = get_session_context('page.close')
    return await session.execute(cdp.page.close())


async def crash() -> None:
    '''
    Crashes renderer on the IO thread, generates minidumps.
    '''
    session = get_session_context('page.crash')
    return await session.execute(cdp.page.crash())


async def create_isolated_world(
        frame_id: FrameId,
        world_name: typing.Optional[str] = None,
        grant_univeral_access: typing.Optional[bool] = None
    ) -> runtime.ExecutionContextId:
    '''
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: An optional name which is reported in the Execution Context.
    :param grant_univeral_access: Whether or not universal access should be granted to the isolated world. This is a powerful
    option, use with caution.
    :returns: Execution context of the isolated world.
    '''
    session = get_session_context('page.create_isolated_world')
    return await session.execute(cdp.page.create_isolated_world(frame_id, world_name, grant_univeral_access))


async def delete_cookie(
        cookie_name: str,
        url: str
    ) -> None:
    '''
    Deletes browser cookie with given name, domain and path.

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    '''
    session = get_session_context('page.delete_cookie')
    return await session.execute(cdp.page.delete_cookie(cookie_name, url))


async def disable() -> None:
    '''
    Disables page domain notifications.
    '''
    session = get_session_context('page.disable')
    return await session.execute(cdp.page.disable())


async def enable() -> None:
    '''
    Enables page domain notifications.
    '''
    session = get_session_context('page.enable')
    return await session.execute(cdp.page.enable())


async def generate_test_report(
        message: str,
        group: typing.Optional[str] = None
    ) -> None:
    '''
    Generates a report for testing.

    :param message: Message to be displayed in the report.
    :param group: Specifies the endpoint group to deliver the report to.
    '''
    session = get_session_context('page.generate_test_report')
    return await session.execute(cdp.page.generate_test_report(message, group))


async def get_app_manifest() -> typing.Tuple[str, typing.List[AppManifestError], typing.Optional[str]]:
    '''


    :returns: a tuple with the following items:
        0. url: Manifest location.
        1. errors: 
        2. data: (Optional) Manifest content.
    '''
    session = get_session_context('page.get_app_manifest')
    return await session.execute(cdp.page.get_app_manifest())


async def get_cookies() -> typing.List[network.Cookie]:
    '''
    Returns all browser cookies. Depending on the backend support, will return detailed cookie
    information in the `cookies` field.

    :returns: Array of cookie objects.
    '''
    session = get_session_context('page.get_cookies')
    return await session.execute(cdp.page.get_cookies())


async def get_frame_tree() -> FrameTree:
    '''
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    '''
    session = get_session_context('page.get_frame_tree')
    return await session.execute(cdp.page.get_frame_tree())


async def get_installability_errors() -> typing.List[str]:
    '''


    :returns: 
    '''
    session = get_session_context('page.get_installability_errors')
    return await session.execute(cdp.page.get_installability_errors())


async def get_layout_metrics() -> typing.Tuple[LayoutViewport, VisualViewport, dom.Rect]:
    '''
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: a tuple with the following items:
        0. layoutViewport: Metrics relating to the layout viewport.
        1. visualViewport: Metrics relating to the visual viewport.
        2. contentSize: Size of scrollable area.
    '''
    session = get_session_context('page.get_layout_metrics')
    return await session.execute(cdp.page.get_layout_metrics())


async def get_navigation_history() -> typing.Tuple[int, typing.List[NavigationEntry]]:
    '''
    Returns navigation history for the current page.

    :returns: a tuple with the following items:
        0. currentIndex: Index of the current navigation history entry.
        1. entries: Array of navigation history entries.
    '''
    session = get_session_context('page.get_navigation_history')
    return await session.execute(cdp.page.get_navigation_history())


async def get_resource_content(
        frame_id: FrameId,
        url: str
    ) -> typing.Tuple[str, bool]:
    '''
    Returns content of the given resource.

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: a tuple with the following items:
        0. content: Resource content.
        1. base64Encoded: True, if content was served as base64.
    '''
    session = get_session_context('page.get_resource_content')
    return await session.execute(cdp.page.get_resource_content(frame_id, url))


async def get_resource_tree() -> FrameResourceTree:
    '''
    Returns present frame / resource tree structure.

    :returns: Present frame / resource tree structure.
    '''
    session = get_session_context('page.get_resource_tree')
    return await session.execute(cdp.page.get_resource_tree())


async def handle_file_chooser(
        action: str,
        files: typing.Optional[typing.List[str]] = None
    ) -> None:
    '''
    Accepts or cancels an intercepted file chooser dialog.

    :param action:
    :param files: Array of absolute file paths to set, only respected with ``accept`` action.
    '''
    session = get_session_context('page.handle_file_chooser')
    return await session.execute(cdp.page.handle_file_chooser(action, files))


async def handle_java_script_dialog(
        accept: bool,
        prompt_text: typing.Optional[str] = None
    ) -> None:
    '''
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: The text to enter into the dialog prompt before accepting. Used only if this is a prompt
    dialog.
    '''
    session = get_session_context('page.handle_java_script_dialog')
    return await session.execute(cdp.page.handle_java_script_dialog(accept, prompt_text))


async def navigate(
        url: str,
        referrer: typing.Optional[str] = None,
        transition_type: typing.Optional[TransitionType] = None,
        frame_id: typing.Optional[FrameId] = None
    ) -> typing.Tuple[FrameId, typing.Optional[network.LoaderId], typing.Optional[str]]:
    '''
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: Referrer URL.
    :param transition_type: Intended transition type.
    :param frame_id: Frame id to navigate, if not specified navigates the top frame.
    :returns: a tuple with the following items:
        0. frameId: Frame id that has navigated (or failed to navigate)
        1. loaderId: (Optional) Loader identifier.
        2. errorText: (Optional) User friendly error message, present if and only if navigation has failed.
    '''
    session = get_session_context('page.navigate')
    return await session.execute(cdp.page.navigate(url, referrer, transition_type, frame_id))


async def navigate_to_history_entry(
        entry_id: int
    ) -> None:
    '''
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    '''
    session = get_session_context('page.navigate_to_history_entry')
    return await session.execute(cdp.page.navigate_to_history_entry(entry_id))


async def print_to_pdf(
        landscape: typing.Optional[bool] = None,
        display_header_footer: typing.Optional[bool] = None,
        print_background: typing.Optional[bool] = None,
        scale: typing.Optional[float] = None,
        paper_width: typing.Optional[float] = None,
        paper_height: typing.Optional[float] = None,
        margin_top: typing.Optional[float] = None,
        margin_bottom: typing.Optional[float] = None,
        margin_left: typing.Optional[float] = None,
        margin_right: typing.Optional[float] = None,
        page_ranges: typing.Optional[str] = None,
        ignore_invalid_page_ranges: typing.Optional[bool] = None,
        header_template: typing.Optional[str] = None,
        footer_template: typing.Optional[str] = None,
        prefer_css_page_size: typing.Optional[bool] = None,
        transfer_mode: typing.Optional[str] = None
    ) -> typing.Tuple[str, typing.Optional[io.StreamHandle]]:
    '''
    Print page as PDF.

    :param landscape: Paper orientation. Defaults to false.
    :param display_header_footer: Display header and footer. Defaults to false.
    :param print_background: Print background graphics. Defaults to false.
    :param scale: Scale of the webpage rendering. Defaults to 1.
    :param paper_width: Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: Paper height in inches. Defaults to 11 inches.
    :param margin_top: Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means
    print all pages.
    :param ignore_invalid_page_ranges: Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.
    Defaults to false.
    :param header_template: HTML template for the print header. Should be valid HTML markup with following
    classes used to inject printing values into them:
    - ``date``: formatted print date
    - ``title``: document title
    - ``url``: document location
    - ``pageNumber``: current page number
    - ``totalPages``: total pages in the document

    For example, ``<span class=title></span>`` would generate span containing the title.
    :param footer_template: HTML template for the print footer. Should use the same format as the ``headerTemplate``.
    :param prefer_css_page_size: Whether or not to prefer page size as defined by css. Defaults to false,
    in which case the content will be scaled to fit the paper size.
    :param transfer_mode: return as stream
    :returns: a tuple with the following items:
        0. data: Base64-encoded pdf data. Empty if |returnAsStream| is specified.
        1. stream: (Optional) A handle of the stream that holds resulting PDF data.
    '''
    session = get_session_context('page.print_to_pdf')
    return await session.execute(cdp.page.print_to_pdf(landscape, display_header_footer, print_background, scale, paper_width, paper_height, margin_top, margin_bottom, margin_left, margin_right, page_ranges, ignore_invalid_page_ranges, header_template, footer_template, prefer_css_page_size, transfer_mode))


async def reload(
        ignore_cache: typing.Optional[bool] = None,
        script_to_evaluate_on_load: typing.Optional[str] = None
    ) -> None:
    '''
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: If set, the script will be injected into all frames of the inspected page after reload.
    Argument will be ignored if reloading dataURL origin.
    '''
    session = get_session_context('page.reload')
    return await session.execute(cdp.page.reload(ignore_cache, script_to_evaluate_on_load))


async def remove_script_to_evaluate_on_load(
        identifier: ScriptIdentifier
    ) -> None:
    '''
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    :param identifier:
    '''
    session = get_session_context('page.remove_script_to_evaluate_on_load')
    return await session.execute(cdp.page.remove_script_to_evaluate_on_load(identifier))


async def remove_script_to_evaluate_on_new_document(
        identifier: ScriptIdentifier
    ) -> None:
    '''
    Removes given script from the list.

    :param identifier:
    '''
    session = get_session_context('page.remove_script_to_evaluate_on_new_document')
    return await session.execute(cdp.page.remove_script_to_evaluate_on_new_document(identifier))


async def reset_navigation_history() -> None:
    '''
    Resets navigation history for the current page.
    '''
    session = get_session_context('page.reset_navigation_history')
    return await session.execute(cdp.page.reset_navigation_history())


async def screencast_frame_ack(
        session_id: int
    ) -> None:
    '''
    Acknowledges that a screencast frame has been received by the frontend.

    :param session_id: Frame number.
    '''
    session = get_session_context('page.screencast_frame_ack')
    return await session.execute(cdp.page.screencast_frame_ack(session_id))


async def search_in_resource(
        frame_id: FrameId,
        url: str,
        query: str,
        case_sensitive: typing.Optional[bool] = None,
        is_regex: typing.Optional[bool] = None
    ) -> typing.List[debugger.SearchMatch]:
    '''
    Searches for given string in resource content.

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: If true, search is case sensitive.
    :param is_regex: If true, treats string parameter as regex.
    :returns: List of search matches.
    '''
    session = get_session_context('page.search_in_resource')
    return await session.execute(cdp.page.search_in_resource(frame_id, url, query, case_sensitive, is_regex))


async def set_ad_blocking_enabled(
        enabled: bool
    ) -> None:
    '''
    Enable Chrome's experimental ad filter on all sites.

    :param enabled: Whether to block ads.
    '''
    session = get_session_context('page.set_ad_blocking_enabled')
    return await session.execute(cdp.page.set_ad_blocking_enabled(enabled))


async def set_bypass_csp(
        enabled: bool
    ) -> None:
    '''
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    '''
    session = get_session_context('page.set_bypass_csp')
    return await session.execute(cdp.page.set_bypass_csp(enabled))


async def set_device_metrics_override(
        width: int,
        height: int,
        device_scale_factor: float,
        mobile: bool,
        scale: typing.Optional[float] = None,
        screen_width: typing.Optional[int] = None,
        screen_height: typing.Optional[int] = None,
        position_x: typing.Optional[int] = None,
        position_y: typing.Optional[int] = None,
        dont_set_visible_size: typing.Optional[bool] = None,
        screen_orientation: typing.Optional[emulation.ScreenOrientation] = None,
        viewport: typing.Optional[Viewport] = None
    ) -> None:
    '''
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
    autosizing and more.
    :param scale: Scale to apply to resulting view image.
    :param screen_width: Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: Screen orientation override.
    :param viewport: The viewport dimensions and scale. If not set, the override is cleared.
    '''
    session = get_session_context('page.set_device_metrics_override')
    return await session.execute(cdp.page.set_device_metrics_override(width, height, device_scale_factor, mobile, scale, screen_width, screen_height, position_x, position_y, dont_set_visible_size, screen_orientation, viewport))


async def set_device_orientation_override(
        alpha: float,
        beta: float,
        gamma: float
    ) -> None:
    '''
    Overrides the Device Orientation.

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    '''
    session = get_session_context('page.set_device_orientation_override')
    return await session.execute(cdp.page.set_device_orientation_override(alpha, beta, gamma))


async def set_document_content(
        frame_id: FrameId,
        html: str
    ) -> None:
    '''
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    '''
    session = get_session_context('page.set_document_content')
    return await session.execute(cdp.page.set_document_content(frame_id, html))


async def set_download_behavior(
        behavior: str,
        download_path: typing.Optional[str] = None
    ) -> None:
    '''
    Set the behavior when downloading a file.

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if
    available (otherwise deny).
    :param download_path: The default path to save downloaded files to. This is requred if behavior is set to 'allow'
    '''
    session = get_session_context('page.set_download_behavior')
    return await session.execute(cdp.page.set_download_behavior(behavior, download_path))


async def set_font_families(
        font_families: FontFamilies
    ) -> None:
    '''
    Set generic font families.

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    '''
    session = get_session_context('page.set_font_families')
    return await session.execute(cdp.page.set_font_families(font_families))


async def set_font_sizes(
        font_sizes: FontSizes
    ) -> None:
    '''
    Set default font sizes.

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    '''
    session = get_session_context('page.set_font_sizes')
    return await session.execute(cdp.page.set_font_sizes(font_sizes))


async def set_geolocation_override(
        latitude: typing.Optional[float] = None,
        longitude: typing.Optional[float] = None,
        accuracy: typing.Optional[float] = None
    ) -> None:
    '''
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: Mock latitude
    :param longitude: Mock longitude
    :param accuracy: Mock accuracy
    '''
    session = get_session_context('page.set_geolocation_override')
    return await session.execute(cdp.page.set_geolocation_override(latitude, longitude, accuracy))


async def set_intercept_file_chooser_dialog(
        enabled: bool
    ) -> None:
    '''
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event `Page.fileChooserOpened` is emitted.
    File chooser can be handled with `page.handleFileChooser` command.

    :param enabled:
    '''
    session = get_session_context('page.set_intercept_file_chooser_dialog')
    return await session.execute(cdp.page.set_intercept_file_chooser_dialog(enabled))


async def set_lifecycle_events_enabled(
        enabled: bool
    ) -> None:
    '''
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    '''
    session = get_session_context('page.set_lifecycle_events_enabled')
    return await session.execute(cdp.page.set_lifecycle_events_enabled(enabled))


async def set_produce_compilation_cache(
        enabled: bool
    ) -> None:
    '''
    Forces compilation cache to be generated for every subresource script.

    :param enabled:
    '''
    session = get_session_context('page.set_produce_compilation_cache')
    return await session.execute(cdp.page.set_produce_compilation_cache(enabled))


async def set_touch_emulation_enabled(
        enabled: bool,
        configuration: typing.Optional[str] = None
    ) -> None:
    '''
    Toggles mouse event-based touch event emulation.

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: Touch/gesture events configuration. Default: current platform.
    '''
    session = get_session_context('page.set_touch_emulation_enabled')
    return await session.execute(cdp.page.set_touch_emulation_enabled(enabled, configuration))


async def set_web_lifecycle_state(
        state: str
    ) -> None:
    '''
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    :param state: Target lifecycle state
    '''
    session = get_session_context('page.set_web_lifecycle_state')
    return await session.execute(cdp.page.set_web_lifecycle_state(state))


async def start_screencast(
        format: typing.Optional[str] = None,
        quality: typing.Optional[int] = None,
        max_width: typing.Optional[int] = None,
        max_height: typing.Optional[int] = None,
        every_nth_frame: typing.Optional[int] = None
    ) -> None:
    '''
    Starts sending each frame using the `screencastFrame` event.

    :param format: Image compression format.
    :param quality: Compression quality from range [0..100].
    :param max_width: Maximum screenshot width.
    :param max_height: Maximum screenshot height.
    :param every_nth_frame: Send every n-th frame.
    '''
    session = get_session_context('page.start_screencast')
    return await session.execute(cdp.page.start_screencast(format, quality, max_width, max_height, every_nth_frame))


async def stop_loading() -> None:
    '''
    Force the page stop all navigations and pending resource fetches.
    '''
    session = get_session_context('page.stop_loading')
    return await session.execute(cdp.page.stop_loading())


async def stop_screencast() -> None:
    '''
    Stops sending each frame in the `screencastFrame`.
    '''
    session = get_session_context('page.stop_screencast')
    return await session.execute(cdp.page.stop_screencast())


async def wait_for_debugger() -> None:
    '''
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
    '''
    session = get_session_context('page.wait_for_debugger')
    return await session.execute(cdp.page.wait_for_debugger())
